package main

import (
	"bufio"
	"bytes"
	"encoding/json"
	"fmt"
	"net/http"
	"os"
	"path/filepath"
	"strings"
)

func generateSummaryWithGemini(result *Result) {
	apiURL, apiKey, err := loadGeminiConfig()
	if err != nil {
		errMsg := fmt.Sprintf("Failed to load Gemini config: %v", err)
		result.Errors = append(result.Errors, errMsg)
		return
	}

	prompt, err := BuildPrompt(result)
	if err != nil {
		errMsg := fmt.Sprintf("Failed to build prompt: %v", err)
		result.Errors = append(result.Errors, errMsg)
		return
	}

	body := map[string]any{
		"contents": []map[string]any{
			{
				"parts": []map[string]string{
					{"text": "You are a senior software engineer specializing in Go security tools.\n" +
						"You will be given a JSON output from a Go-based vulnerability scanner. Analyze and summarize the key findings clearly and concisely for inclusion in a security report.\n\n" + prompt},
				},
			},
		},
	}

	jsonBody, err := json.Marshal(body)
	if err != nil {
		result.Errors = append(result.Errors, fmt.Sprintf("Failed to marshal Gemini request: %v", err))
		return
	}

	fullURL := fmt.Sprintf("%s?key=%s", apiURL, apiKey)
	req, err := http.NewRequest("POST", fullURL, bytes.NewReader(jsonBody))
	if err != nil {
		result.Errors = append(result.Errors, fmt.Sprintf("Failed to create Gemini request: %v", err))
		return
	}
	req.Header.Set("Content-Type", "application/json")

	resp, err := http.DefaultClient.Do(req)
	if err != nil {
		result.Errors = append(result.Errors, fmt.Sprintf("Failed to connect to Gemini API: %v", err))
		return
	}
	defer resp.Body.Close()

	var response struct {
		Candidates []struct {
			Content struct {
				Parts []struct {
					Text string `json:"text"`
				} `json:"parts"`
			} `json:"content"`
		} `json:"candidates"`
	}

	if err := json.NewDecoder(resp.Body).Decode(&response); err != nil {
		result.Errors = append(result.Errors, fmt.Sprintf("Failed to decode Gemini response: %v", err))
		return
	}

	if len(response.Candidates) > 0 && len(response.Candidates[0].Content.Parts) > 0 {
		result.Summary = response.Candidates[0].Content.Parts[0].Text
	} else {
		result.Summary = "No summary generated by Gemini."
	}
}

func BuildPrompt(result *Result) (string, error) {

	promptResult := &Result{
		IsVulnerable: result.IsVulnerable,
		UsedImports:  result.UsedImports,
		GoCVE:        result.GoCVE,
		CVE:          result.CVE,
		Repository:   result.Repository,
		Branch:       result.Branch,
		Errors:       result.Errors,
	}
	resultJson, err := json.MarshalIndent(promptResult, "", "  ")
	if err != nil {
		return "", err
	}

	var sb strings.Builder

	sb.WriteString(`You are a senior software engineer specializing in Go security tools.

I have a JSON that represents the output of a Go-based vulnerability scanner. I want you to summarize its content for report. Reply only with the markdown without triple backticks. Be straight to the point in an elaborative manner.

This JSON contains:
- IsVulnerable: whether the project is affected.
- UsedImports: import packages and how they are used in codebase.
- Files: where symbols occur.
- AffectedImports: vulnerable symbols and fixed versions of the CVE ID.
- GoCVE: Go vulnerability ID.
- CVE: General vulnerability ID.
- Repository/Branch/Directory: context of the scanned code.
- Errors: scanning issues if any.

Here is JSON result after the scanning:

`)
	sb.WriteString("```json\n")
	sb.Write(resultJson)
	sb.WriteString("\n```\n\n")

	sb.WriteString(`Please provide a concise and clear summary for technical and security teams including:
- Whether the project is vulnerable and why.
  - If yes
    - If any field is null, ignore it.
    - Which symbols and imports are involved only if the code is vulnerable.
    - Which version should be used to fix it and how.
  - If no,
    - Simply say 'No vulnerability'.
- Any errors or issues to be addressed.`)

	return sb.String(), nil
}

func loadGeminiConfig() (url string, key string, err error) {
	homeDir, err := os.UserHomeDir()
	if err != nil {
		return "", "", fmt.Errorf("could not find user home directory: %w", err)
	}

	confPath := filepath.Join(homeDir, ".gemini.conf")
	file, err := os.Open(confPath)
	if err != nil {
		return "", "", fmt.Errorf("could not open config file: %w", err)
	}
	defer file.Close()

	scanner := bufio.NewScanner(file)
	for scanner.Scan() {
		line := scanner.Text()
		if strings.HasPrefix(line, "API_URL=") {
			url = strings.TrimPrefix(line, "API_URL=")
		} else if strings.HasPrefix(line, "API_KEY=") {
			key = strings.TrimPrefix(line, "API_KEY=")
		}
	}

	if err := scanner.Err(); err != nil {
		return "", "", fmt.Errorf("error reading config file: %w", err)
	}

	if url == "" || key == "" {
		return "", "", fmt.Errorf("API_URL or API_KEY not found in config")
	}

	return url, key, nil
}
